    <!-- Hidden script to pass image data from Django to JavaScript -->
    <script id="productImageData" type="application/json">
        [
            {% for image in product.images.all %}
            {"url": "{{ image.image.url }}", "type": "{{ image.type }}"}{% if not forloop.last %},{% endif %}
            {% endfor %}
        ]
    </script>

    <!-- Hidden script to pass product ID and variant flags -->
    <script id="productVariantData" type="application/json">
        {
            "productId": {{ product.id }},
            "hasSizes": {{ has_sizes|yesno:"true,false" }},
            "hasColorsOnly": {{ has_colors_only|yesno:"true,false" }}
        }
    </script>

    {# NEW: Hidden script to pass user authentication and admin status to JavaScript #}
    <script id="userAuthData" type="application/json">
        {
            "isAuthenticated": {% if request.user.is_authenticated %}true{% else %}false{% endif %},
            "isAdmin": {% if is_admin %}true{% else %}false{% endif %}
        }
    </script>

    <script>
        // Read product image data from the hidden JSON script tag
        const productImagesData = JSON.parse(document.getElementById('productImageData').textContent);

        // Prepare the productImages array for the slider, ensuring 'Main' image is first
        let productImages = [];
        let mainImageUrl = '';

        // Find the main image
        const mainImageObj = productImagesData.find(img => img.type === 'Main');
        if (mainImageObj) {
            mainImageUrl = mainImageObj.url;
            productImages.push(mainImageUrl); // Add main image first
        }

        // Add other images, ensuring no duplicates of the main image
        productImagesData.forEach(imgData => {
            if (imgData.url !== mainImageUrl) {
                productImages.push(imgData.url);
            }
        });

        // Fallback if no images are found at all
        if (productImages.length === 0) {
            productImages.push("https://placehold.co/600x600/E0E0E0/333333?text=No+Image");
        }


        let currentImageIndex = 0;

        const mainProductImage = document.getElementById('mainProductImage');
        const thumbnailGallery = document.getElementById('thumbnailGallery');
        const prevImageBtn = document.getElementById('prevImageBtn');
        const nextImageBtn = document.getElementById('nextImageBtn');

        // Dynamically generate thumbnails
        function generateThumbnails() {
            thumbnailGallery.innerHTML = ''; // Clear existing thumbnails
            // Only generate thumbnails if there's more than one image
            if (productImages.length > 1) {
                productImages.forEach((imgUrl, index) => {
                    const thumb = document.createElement('img');
                    thumb.src = imgUrl;
                    thumb.alt = `Thumbnail View ${index + 1}`;
                    thumb.classList.add('thumbnail', 'w-20', 'h-20', 'object-cover', 'rounded-lg', 'cursor-pointer', 'border-2', 'border-transparent', 'hover:border-[#FF1493]', 'transition-all', 'duration-200');
                    thumb.dataset.imageIndex = index;
                    thumb.addEventListener('click', () => changeMainImage(imgUrl, index));
                    thumbnailGallery.appendChild(thumb);
                });
            }
            updateThumbnailActiveState(); // Set active state for the current thumbnail
        }

        // Function to change the main product image
        function changeMainImage(imageSrc, index) {
            mainProductImage.src = imageSrc;
            currentImageIndex = index;
            updateThumbnailActiveState();
        }

        // Update active state of thumbnails
        function updateThumbnailActiveState() {
            const thumbnails = thumbnailGallery.querySelectorAll('.thumbnail');
            thumbnails.forEach((thumb, index) => {
                if (index === currentImageIndex) {
                    thumb.classList.add('border-[#FF1493]');
                } else {
                    thumb.classList.remove('border-[#FF1493]');
                }
            });
        }

        // Function to show next image
        function showNextImage() {
            currentImageIndex = (currentImageIndex + 1) % productImages.length;
            mainProductImage.src = productImages[currentImageIndex];
            updateThumbnailActiveState(); // Update active thumbnail on arrow click
        }

        // Function to show previous image
        function showPreviousImage() {
            currentImageIndex = (currentImageIndex - 1 + productImages.length) % productImages.length;
            mainProductImage.src = productImages[currentImageIndex];
            updateThumbnailActiveState(); // Update active thumbnail on arrow click
        }

        // Event listeners for arrows
        prevImageBtn.addEventListener('click', showPreviousImage);
        nextImageBtn.addEventListener('click', showNextImage);

        // Responsive display logic for image gallery
        function handleImageGalleryResponsiveness() {
            const hasMultipleImages = productImages.length > 1;
            const isLargeScreen = window.innerWidth >= 1024; // Tailwind's 'lg' breakpoint

            if (hasMultipleImages) {
                // If multiple images, show arrows on small screens, thumbnails on large screens
                if (isLargeScreen) {
                    thumbnailGallery.classList.remove('hidden');
                    prevImageBtn.classList.add('hidden');
                    nextImageBtn.classList.add('hidden');
                } else {
                    thumbnailGallery.classList.add('hidden');
                    prevImageBtn.classList.remove('hidden');
                    nextImageBtn.classList.remove('hidden');
                }
            } else {
                // If only one image, hide everything
                thumbnailGallery.classList.add('hidden');
                prevImageBtn.classList.add('hidden');
                nextImageBtn.classList.add('hidden');
            }
        }

        // Initial calls:
        // 1. Generate thumbnails first (if any)
        generateThumbnails();
        // 2. Set the initial main image based on the prepared productImages array
        if (productImages.length > 0) {
            changeMainImage(productImages[0], 0); // Always start with the first image (which is main if available)
        } else {
            // Fallback if no images are present at all (should be handled by productImages.push above)
            mainProductImage.src = "https://placehold.co/600x600/E0E0E0/333333?text=No+Image";
        }
        // 3. Handle responsiveness for elements based on image count and screen size
        window.addEventListener('resize', handleImageGalleryResponsiveness);
        handleImageGalleryResponsiveness(); // Call on load to set initial state


        // Function to update quantity
        function updateQuantity(change) {
            const quantityInput = document.getElementById('quantity');
            let currentQuantity = parseInt(quantityInput.value);
            currentQuantity += change;
            if (currentQuantity < 1) {
                currentQuantity = 1; // Quantity cannot be less than 1
            }
            quantityInput.value = currentQuantity;
        }

        // --- ADD TO CART FUNCTIONALITY ---
        const productVariantData = JSON.parse(document.getElementById('productVariantData').textContent);
        const productId = productVariantData.productId;
        const hasSizes = productVariantData.hasSizes;
        const hasColorsOnly = productVariantData.hasColorsOnly;

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.startsWith(name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
</script>
<script>
    // --- Message Toast ---
    function showMessage(message, type) {
        const messageBox = document.createElement('div');
        messageBox.textContent = message;
        messageBox.className = `fixed bottom-4 right-4 p-4 rounded-lg shadow-lg text-white z-50 ${type === 'success' ? 'bg-green-500' : 'bg-red-500'}`;
        document.body.appendChild(messageBox);
        setTimeout(() => messageBox.remove(), 3000);
    }

    // --- Star Rating Logic ---
    const starRatingContainer = document.getElementById('starRating');
    const selectedRatingInput = document.getElementById('selectedRating');
    const numStars = 5;

    for (let i = 1; i <= numStars; i++) {
        const star = document.createElement('span');
        star.classList.add('cursor-pointer', 'text-gray-300', 'hover:text-yellow-400', 'transition-colors', 'duration-200');
        star.innerHTML = '<svg class="w-6 h-6 fill-current" viewBox="0 0 24 24"><path d="M12 .587l3.668 7.568 8.332 1.151-6.064 5.828 1.48 8.279L12 18.896l-7.416 3.817 1.48-8.279-6.064-5.828 8.332-1.151z"/></svg>';
        star.dataset.value = i;
        star.addEventListener('click', () => setRating(i));
        star.addEventListener('mouseover', () => highlightStars(i));
        star.addEventListener('mouseout', () => highlightStars(selectedRatingInput.value));
        starRatingContainer.appendChild(star);
    }

    function setRating(rating) {
        selectedRatingInput.value = rating;
        highlightStars(rating);
    }

    function highlightStars(rating) {
        const stars = starRatingContainer.children;
        for (let i = 0; i < stars.length; i++) {
            if (parseInt(stars[i].dataset.value) <= rating) {
                stars[i].classList.add('text-yellow-400');
                stars[i].classList.remove('text-gray-300');
            } else {
                stars[i].classList.add('text-gray-300');
                stars[i].classList.remove('text-yellow-400');
            }
        }
    }

    // --- AJAX Submit Review ---
    document.getElementById('reviewForm').addEventListener('submit', function(event) {
        event.preventDefault();

        const thought = document.getElementById('reviewThought').value.trim();
        const rating = document.getElementById('selectedRating').value;

        {% if request.user.is_authenticated %}
            const email = "{{ customer.email }}";
        {% else %}
            const emailField = document.getElementById('reviewerEmail');
            const email = emailField ? emailField.value.trim() : '';
            if (!email) {
                showMessage("Please enter your email.", "error");
                return;
            }
        {% endif %}

        if (!thought || rating === "0") {
            showMessage("Please fill in all fields and choose a rating.", "error");
            return;
        }

        fetch("{% url 'ajax_create_comment' %}", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}"
            },
            body: JSON.stringify({
                gmail: email,
                comment: thought,
                rating: rating,
                product_id: "{{ product.id }}"
            })
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP status ${response.status}`);
            return response.json();
        })
        .then(data => {
            if (data.success) {
                addReviewToDisplay(data.email, data.comment, parseInt(data.rating), new Date(), data.comment_id);
                showMessage("Your review has been submitted!", "success");
                document.getElementById('reviewForm').reset();
                setRating(0);
            } else {
                showMessage(data.message || "Something went wrong.", "error");
            }
        })
        .catch(error => {
            console.error(error);
            showMessage("Failed to submit review. Try again.", "error");
        });
    });

    // --- Add Comment to Display ---
    function addReviewToDisplay(email, thought, rating, timestamp, commentId = null) {
        const reviewsList = document.getElementById('reviewsList');

        // Remove "No reviews yet" message if it exists
        const noReviewsMessage = document.querySelector('#reviewsList > p.text-gray-600');
        if (noReviewsMessage) noReviewsMessage.remove();

        const newReviewDiv = document.createElement('div');
        const displayId = commentId || `temp-${Date.now()}`;
        newReviewDiv.classList.add('bg-gray-50', 'p-4', 'rounded-lg', 'shadow-sm', 'relative');
        newReviewDiv.id = `comment-${displayId}`;

        let starsHtml = '';
        for (let i = 1; i <= numStars; i++) {
            starsHtml += `<svg class="w-5 h-5 fill-current ${i <= rating ? 'text-yellow-400' : 'text-gray-300'}" viewBox="0 0 24 24"><path d="M12 .587l3.668 7.568 8.332 1.151-6.064 5.828 1.48 8.279L12 18.896l-7.416 3.817 1.48-8.279-6.064-5.828 8.332-1.151z"/></svg>`;
        }

        newReviewDiv.innerHTML = `
            <div class="flex items-center mb-2">
                <span class="font-semibold text-gray-800 mr-2">${email}</span>
            </div>
            <div class="flex flex-wrap items-center justify-between mb-2 text-yellow-400">
                <div class="flex flex-wrap">${starsHtml}</div>
                <span class="text-xs text-gray-400">Now</span>
            </div>
            <p class="text-gray-700">"${thought}"</p>
            <div class="flex justify-end items-center mt-3">
                <button onclick="deleteComment('${displayId}', this.closest('.bg-gray-50'))" class="text-red-500 hover:text-red-700 focus:outline-none p-1 rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            <div class="replies-container mt-3 space-y-3"></div>
            <div id="replyForm-${displayId}" class="reply-form-container mt-4 p-3 bg-gray-100 rounded-lg border border-gray-200 hidden">
                <h4 class="font-semibold text-gray-700 mb-2">Your Reply:</h4>
                <textarea class="reply-textarea shadow border rounded-lg w-full py-2 px-3 text-gray-700" rows="2" placeholder="Write your reply..."></textarea>
                <button onclick="submitReply('${displayId}', this.previousElementSibling.value, this.closest('.reply-form-container'))" class="mt-2 bg-blue-500 text-white py-1.5 px-4 rounded-lg text-sm font-semibold hover:bg-blue-600 transition-colors duration-300">Post Reply</button>
            </div>`;
        reviewsList.prepend(newReviewDiv);
    }

    // --- Check if all reviews are deleted ---
    function checkIfNoReviews() {
        const reviewsList = document.getElementById('reviewsList');
        const comments = reviewsList.querySelectorAll('.bg-gray-50');
        if (comments.length === 0) {
            const noReviewMsg = document.createElement('p');
            noReviewMsg.className = 'text-gray-600';
            noReviewMsg.textContent = 'No reviews yet. Be the first to leave one!';
            reviewsList.appendChild(noReviewMsg);
        }
    }

    // --- Delete Comment or Reply ---
    function deleteComment(id, element) {
        if (!confirm("Are you sure you want to delete this?")) return;

        // Handle temp (unsaved) comment
        if (id.startsWith("temp-")) {
            element.remove();
            showMessage("Comment removed.", "success");
            checkIfNoReviews();
            return;
        }

        const isReply = element.classList.contains("bg-gray-100");
        const url = isReply ? "{% url 'delete_reply' %}" : "{% url 'delete_comment' %}";
        const paramKey = isReply ? "reply_id" : "comment_id";

        fetch(url, {
            method: "POST",
            headers: {
                "X-CSRFToken": "{{ csrf_token }}",
                "Content-Type": "application/x-www-form-urlencoded"
            },
            body: new URLSearchParams({ [paramKey]: id })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                element.remove();
                showMessage("Deleted successfully.", "success");
                checkIfNoReviews();
            } else {
                showMessage(data.message || "Failed to delete.", "error");
            }
        })
        .catch(error => {
            console.error(error);
            showMessage("Error deleting. Try again.", "error");
        });
    }

    // --- Toggle Reply Form ---
    function showReplyForm(commentId) {
        const form = document.getElementById(`replyForm-${commentId}`);
        if (form) {
            form.classList.toggle('hidden');
            if (!form.classList.contains('hidden')) {
                const textarea = form.querySelector('.reply-textarea');
                textarea.value = '';
                textarea.focus();
            }
        }
    }

    // --- Submit Reply ---
    function submitReply(commentId, replyText, replyFormElement) {
        if (!replyText.trim()) {
            showMessage("Reply cannot be empty.", "error");
            return;
        }

        fetch("{% url 'ajax_create_reply' %}", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}"
            },
            body: JSON.stringify({
                comment_id: commentId,
                reply_text: replyText
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const commentElement = document.getElementById(`comment-${commentId}`);
                const container = commentElement.querySelector('.replies-container');

                const newReply = document.createElement('div');
                newReply.id = `reply-${data.reply_id}`;
                newReply.className = 'mt-3 p-3 bg-gray-100 rounded-lg border border-gray-200 relative';
                newReply.innerHTML = `
                    <div class="flex items-center mb-1">
                        <span class="font-semibold text-pink-600 mr-2">Admin</span>
                        <span class="text-xs text-gray-400">Now</span>
                    </div>
                    <p class="text-gray-700">"${data.reply_text}"</p>
                    <button onclick="deleteComment('${data.reply_id}', this.closest('.bg-gray-100'))" class="absolute bottom-2 right-2 text-red-500 hover:text-red-700 focus:outline-none p-1 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                container.appendChild(newReply);
                replyFormElement.classList.add('hidden');
                replyFormElement.querySelector('.reply-textarea').value = '';
                showMessage("Reply posted successfully!", "success");
            } else {
                showMessage(data.message || "Failed to post reply.", "error");
            }
        })
        .catch(error => {
            console.error(error);
            showMessage("Error posting reply. Try again.", "error");
        });
    }
</script>

    <script>
        // Store good images globally accessible by their good ID
        const allgoodImagesData = {};

        window.onload = () => {
            {% for good in goods %}
            // Populate allgoodImagesData
            allgoodImagesData[{{ good.id }}] = [
                {% for image in good.images.all %}
                "{{ image.image.url }}"{% if not forloop.last %}, {% endif %}
                {% endfor %}
            ];

            // Start auto slideshow only if there are images available
            if (allgoodImagesData[{{ good.id }}].length > 0) {
                startAutoSlideshow('img{{ good.id }}', allgoodImagesData[{{ good.id }}], {{ good.id }});
            }
            {% endfor %}
        };

        // Automatic slideshow settings
        var autoSlideshowInterval = 3000; // Time between image changes (ms)
        var autoSlideshowTimers = {};

        // Function to change the image
        function changeImage(id, direction, goodImages) {
            var currentImage = document.getElementById(id);
            if (!currentImage || goodImages.length === 0) return;

            var currentSrc = currentImage.src;

            // Find the current index of the image in the array
            // Use includes for more robust matching as full URL might vary slightly
            var currentIndex = goodImages.findIndex(imgUrl => currentSrc.includes(imgUrl));

            // Fallback if current image not found in array (e.g., first load of a dynamic image)
            if (currentIndex === -1) {
                currentIndex = 0; // Default to the first image in the list
            }

            // Calculate the next index in a circular manner
            var nextIndex = (currentIndex + direction + goodImages.length) % goodImages.length;

            // Update the image source
            currentImage.src = goodImages[nextIndex];
        }

        // Start automatic slideshow
        function startAutoSlideshow(id, goodImages, cardNumber) {
            stopAutoSlideshow(cardNumber); // Clear any existing timers
            if (goodImages.length > 1) { // Only start slideshow if more than one image
                autoSlideshowTimers[cardNumber] = setInterval(() => {
                    changeImage(id, 1, goodImages);
                }, autoSlideshowInterval);
            }
        }

        // Stop automatic slideshow
        function stopAutoSlideshow(cardNumber) {
            if (autoSlideshowTimers[cardNumber]) {
                clearInterval(autoSlideshowTimers[cardNumber]);
                delete autoSlideshowTimers[cardNumber];
            }
        }

        // Manual change (stops auto slideshow temporarily)
        function manualChangeImage(id, direction, cardNumber) {
            const goodImages = allgoodImagesData[cardNumber]; // Get the correct array using the cardNumber
            if (!goodImages || goodImages.length <= 1) return; // Safeguard if array not found or only one image

            stopAutoSlideshow(cardNumber); // Stop auto slideshow
            changeImage(id, direction, goodImages); // Change image manually
            // Restart auto slideshow after a short delay to allow user to see manual change
            setTimeout(() => {
                startAutoSlideshow(id, goodImages, cardNumber);
            }, 1000); // Restart after 1 second, adjust as needed
        }
    </script>


<script>
    const productLimit = {{ product.limit }};

    function updateQuantity(change) {
        const quantityInput = document.getElementById('quantity');
        let currentQuantity = parseInt(quantityInput.value);
        let newQuantity = currentQuantity + change;

        if (newQuantity < 0) newQuantity = 0;
        if (newQuantity > productLimit) {
            showMessage(`Product limit of ${productLimit} reached`, "error");
            return;
        }

        quantityInput.value = newQuantity;
    }

   function addToCart() {
        const productId = "{{ product.id }}";
        const productLimit = {{ product.limit }};
        const quantity = parseInt(document.getElementById('quantity').value);
        const size = document.getElementById('sizes') ? document.getElementById('sizes').value : null;
        const color = document.getElementById('colors') ? document.getElementById('colors').value : null;

        // Validate quantity
        if (isNaN(quantity) || quantity <= 0) {
            showMessage("Please select a valid quantity", "error");
            return;
        }

        if (quantity > productLimit) {
            showMessage(`Product limit surpassed (max: ${productLimit})`, "error");
            return;
        }

        // Validate size
        if (document.getElementById('sizes') && !size) {
            showMessage("Please select a size", "error");
            return;
        }

        // Validate color
        if (document.getElementById('colors') && !color) {
            showMessage("Please select a color", "error");
            return;
        }

        // Send data to backend
        fetch("{% url 'add_to_cart' product.id %}", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}",
            },
            body: JSON.stringify({
                quantity,
                size,
                color
            }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message || "Product added to cart!", "success");
            } else {
                showMessage(data.message || "Something went wrong", "error");
            }
        })
        .catch(error => {
            showMessage("Error adding to cart", "error");
            console.error(error);
        });
    }
</script>
<script>
    function updateDiscountPercentageDisplay() {
        const priceElement = document.querySelector('[data-price]');
        const discountedPriceElement = document.querySelector('[data-discounted-price]');
        const discountPercentageSpan = document.getElementById('discountPercentage');

        if (priceElement && discountedPriceElement && discountPercentageSpan) {
            const originalPrice = parseFloat(priceElement.dataset.price);
            const discountedPrice = parseFloat(discountedPriceElement.dataset.discountedPrice);

            if (!isNaN(originalPrice) && !isNaN(discountedPrice) && originalPrice > 0 && discountedPrice < originalPrice) {
                const discount = originalPrice - discountedPrice;
                const percentage = (discount / originalPrice) * 100;
                discountPercentageSpan.textContent = `(${percentage.toFixed(0)}% Off)`;
            } else {
                discountPercentageSpan.textContent = '';
            }
        }
    }

    document.addEventListener('DOMContentLoaded', updateDiscountPercentageDisplay);
</script>

